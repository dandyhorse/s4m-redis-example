// ВАЖНО: Если нужно — постоянное хранение данных можно отключить. Это — конфигурация, при использовании которой Redis работает быстрее всего, но при этом не гарантируется надёжное хранение данных.

// Разница между способами хранения снепшотов (RDB против AOF):

// 1. RDB (Redis Database — снимок/дамп):
//    -Создает компактный бинарный файл (dump.rdb) с полной копией данных на момент снэпшота.
//
//    - Преимущества:
//    - - Быстрое сохранение (fork процесс),
//    - - Компактный размер,
//    - - Быстрое восстановление для больших датасетов (минуты).
//
//    - Недостатки:
//    - - Потеря данных между снапшотами (RPO — recovery point objective: минуты/часы),
//    - - Меньшая ненадёжность (может потерять последние изменения).
//
//    - Когда использовать: Кэш/сессии, где потеря OK;
//
// 2. AOF (Append Only File — лог операций):
//    Записывает каждую write-команду (SET, DEL и т.д.) в текстовый файл (appendonly.aof) как последовательность команд.
//
//   - Преимущества:
//   - - Минимальная потеря данных (RPO: <1 сек);
//   - - Легко читаем/редактируем;
//   - - Как следствие, выше надёжность;
//
//   - Недостатки:
//   - - Файл растет, как-будто скушал дрожжи и сел на отопление (нужно настраивать ротацию (!));
//   - - Mедленное восстановление (по сути, просто идёт линейно по всем записанным командам, могут быть ЧАСЫ для больших логов);
//
//   - Когда использовать: Транзакционные данные;
//
//  Некоторый вердикт:
//  - Хранение:
//  - - RDB — бинарный дамп (компактный, но не читаемый);
//  - - AOF — текстовый лог (читаемый, но как следствие, многабукав);
//  - Производительность: RDB быстрее на сохранение (background), когда AOF нагружает I/O (каждая операция это вполне себе WRITE TO THE END OF LOG FILE).
//
//  - Размер:
//  - - RDB меньше (бинарь);
//  - - AOF, соответственно, больше, но с auto-rewrite (BGREWRITEAOF) сжимается.
//  - Безопасность: Оба фоновый процесс, но AOF безопаснее при краше (меньше потенциальных потерь).
//
// Вся эта лабуда происходит через форк процесса, тут самое интересное, хорошее объяснение есть на Хабре + AI:
//
// Определение:
// Форк — это когда операционная система, по команде, вызванной неким процессом, создаёт новый процесс, копируя родительский процесс.
// В результате в нашем распоряжении оказывается новый ID процесса и ещё некоторые полезные сведения. При этом только что созданный форк процесса (процесс-потомок) может взаимодействовать с процессом-родителем.
//
// Хороший вопрос: Как скопировать процесс Redis и не столкнуться с нехваткой памяти (x2)?
// По пунктам отвечаем:
// 1) Имеют общий доступ к памяти на чтение (не нужно создавать её копию, но ...)
// 2) Сopy On Write - механизм, который выделяет память только для новых данных, когда RDB + AOF пишут то, что уже прочитали на момент создания форка
// 3) КЛЮЧЕВОЕ дочерний процесс НИКОГДА не видит новые участки памяти (которые обновились после создания форка). Иными словами, механизм сохранения Redis RDB / AOF всегда работают со снепшотом, который был доступен на момент создания форка

import { redis } from '../config';

// Тут стоит отметить, что это вообще редко управляется руками, чаще (как и в нашем docker-compose.yaml) это стартовые настройки, но мы всё же посмотрим,
// как это может выглядить с точки зрения кода:

const demoPersistence = async () => {
  await redis.set('key', 'value');

  // RDB: Синхронный снимок (блокирует сервер, редко в проде, но если важно делить снепшоты)
  // Команда SAVE: Создает dump.rdb в /data (volume в Docker).
  await redis.sendCommand(['SAVE']);
  console.log('RDB: Синхронный снимок сохранен (dump.rdb в volume)');

  // Асинхронный BGSAVE (рекомендуется): Фоновое сохранение RDB.
  await redis.sendCommand(['BGSAVE']);
  console.log('RDB: Асинхронный BGSAVE запущен (не ждет завершения!)');

  // AOF: Требует appendonly yes в conf.
  // Каждая write уже логируется. Для проверки: redis-cli > CONFIG GET appendonly

  // AOF Rewrite: Сжимает лог (background).
  await redis.sendCommand(['BGREWRITEAOF']);
  console.log('AOF: Background rewrite запущен для сжатия лога');

  await redis.flushAll();
};

demoPersistence().catch(console.error);
