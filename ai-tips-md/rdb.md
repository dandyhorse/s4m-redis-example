Мы запускаем Redis в гибридном режиме, где используем и RDB, и AOF.

RDB даёт быстрые и дешёвые снепшоты, а AOF минимизирует потерю данных.

Благодаря aof-use-rdb-preamble мы получаем быстрый старт, потому что Redis поднимается как RDB, а затем догоняет последние команды из AOF.

Политика save настроена по градации нагрузки — чем больше изменений, тем чаще снимки.

В итоге мы получаем оптимальный баланс: минимум потерь, высокая скорость и стабильность в проде.

Коротко и по-алгоритму — без маркетинга, как на техническом митапе.

### Ключевая идея

В Redis **нет отдельных независимых таймеров для каждого `save`-правила**. Есть одно значение `lastsave` (время последнего успешного RDB), есть счётчик изменений `dirty` (количество команд, изменивших данные с момента последнего snapshot или сброса `dirty`) и есть список правил `save` вида `(seconds, changes)`. Каждое правило — просто условие: **если прошло ≥ `seconds` с `lastsave` И `dirty` ≥ `changes`, то запускаем RDB (bgsave)**.

Алгоритм проверки выполняется периодически (серверный cron-тик), не по отдельным таймерам. При первой подходящей проверке Redis запускает bgsave и прекращает дальнейшую проверку на этой итерации.

---

### Что именно происходит (алгоритм, шаг за шагом)

1. **При старте**: `lastsave = time_of_last_rdb`, `dirty = 0`.
2. **При каждой записи**: `dirty++` (или увеличивается соответствующим количеством изменений).
3. **Периодически (serverCron, примерно каждые 100 мс)** Redis перебирает `save`-правила в порядке конфигурации и для каждого проверяет:

   ```
   if (now - lastsave >= seconds && dirty >= changes) then
       if (no bgsave in progress) start bgsave; break out of loop;
   ```

   — то есть на первой попавшейся паре (seconds, changes), удовлетворённой условиям, он запускает bgsave и дальше по правилам в этой тик-итерации не идёт.
4. **После успешного bgsave**: `lastsave` обновляется на время завершения, `dirty` остаётся (возможно) уменьшен/сброшен в зависимости от того, какие изменения попали в RDB; в обычном случае родитель сбрасывает `dirty` на 0 или корректирует его (в реализации считается, что snapshot "покрыл" все изменения до момента fork).
5. **Если bgsave уже выполняется** — новые условия на запуск RDB будут проигнорированы до завершения текущего bgsave (Redis не запускает второй bgsave параллельно).

---

### Применительно к твоему сценарию: 00:00 — 10k записей за 1 минуту

Конфиг:

* `(900, 1)`
* `(300, 10)`
* `(60, 10000)`

Предположим `lastsave = 00:00` и между 00:00 и 00:01 пришло ровно 10 000 изменений.

* До 00:01 ни одно правило **по времени** не выполнится (требуется 60s, 300s или 900s).
* В момент, когда `now - lastsave` достигает 60 секунд (в ~00:01), cron-тик запустит проверку правил. Тогда:

  * Правило `(900,1)` — **не выполнено** (900s не прошло).
  * `(300,10)` — **не выполнено** (300s не прошло).
  * `(60,10000)` — **выполнено**, потому что и время прошло (≥60s), и `dirty >= 10000`.
* Redis запустит **один** bgsave по третьему правилу. Никакого «переключения между таймерами» не происходит: правила не переключают таймеры — они просто условия, проверяемые относительно `lastsave`.

Если бы, гипотетически, `lastsave` был старше 900s и `dirty` >= 10000, то на той же проверке сработало бы **первое правило**, потому что Redis проверяет правила в порядке конфигурации и запускает bgsave на первой удовлетворённой паре.

---

### Несколько важных нюансов / кейсов

* **Нет параллельных RDB**: если bgsave уже идёт, новый не стартует, даже если условия выполняются. Условие будет снова проверено на следующих cron-тиках после завершения.
* **Правила не «переключают таймеры»**: они зависят от `lastsave`. После успешного RDB `lastsave` сбрасывает отсчёт, и расчёт времени идёт заново.
* **Если `dirty` достигает порога раньше, чем прошло `seconds`** — ничего не случится до тех пор, пока не пройдет требуемое `seconds`. То есть правило — это логическое `AND` двух ограничений (время **и** изменения).
* **Порядок правил важен**: первая удовлетворённая — запускает bgsave. Поэтому при составлении набора правил следи за порядком, если есть перекрывающиеся условия.
* **AOF** — отдельный механизм: `appendfsync everysec` fsync'ит каждые ~1 секунду; `bgrewriteaof` (очистка AOF) запускается по своим порогам (`auto-aof-rewrite-percentage` и `min-size`) и проверяется тоже периодически. Это не мешает RDB, но может конкурировать за IO.

---

> Сработает таймер из первого правила, а затем переключится на таймер из третьего или сразу отработает третье?

Ни то, ни другое. **Нет отдельных таймеров**. В 00:01 будет произведена проверка всех правил в порядке конфигурации и будет запущено **то** правило, которое **перво**е удовлетворит условию `(now - lastsave >= seconds) && (dirty >= changes)`. В твоём примере это будет третье правило `(60,10000)` — оно запустит bgsave сразу, никакого «переключения» между таймерами не происходит.



now - lastsave  >= rule.seconds
dirty           >= rule.changes


```
function checkPersistenceConditions():
    now = currentTime()
    time_since_lastsave = now - server.lastsave

    for each rule in server.saveparams:   // правило представляет (seconds, changes)
        seconds = rule.seconds
        changes = rule.changes

        if (time_since_lastsave >= seconds 
            AND server.dirty >= changes):
            
            // Условие правила выполнено → запускаем bgsave
            bgsave_start()
            return
```
```
every 100ms:
    now = current time
    for each save_rule in ordered list:
        if now - lastsave >= save_rule.seconds:
            if dirty >= save_rule.changes:
                run_bgsave()
                break
```


# Слайды доклада: Гибридная персистентность Redis (RDB + AOF)

---

## Слайд 1. Заголовок

### **Персистентность в Redis: RDB + AOF**

**Как работает гибридный подход и почему он используется в проде**

---

## Слайд 2. Зачем вообще нужна персистентность?

* Redis хранит данные в памяти
* При перезапуске без персистентности данные исчезнут
* Цели:

  * Минимизировать потерю данных (durability)
  * Обеспечить быструю загрузку
  * Не убивать производительность диска

---

## Слайд 3. Два механизма Redis

### **RDB (Redis Database Snapshot)**

* Периодические снепшоты памяти
* Быстро грузится
* Лёгкая нагрузка на диск
* Возможна потеря последних N секунд данных

### **AOF (Append-Only File)**

* Лог команд, изменяющих данные
* Минимальная потеря (1 секунда при everysec)
* Может разрастись
* Медленнее загрузка, если файл большой

---

## Слайд 4. Почему гибрид? (RDB + AOF)

* RDB даёт **скорость восстановления**
* AOF даёт **минимальные потери**
* Гибридный AOF с RDB-преамбулой:

  * Загружается быстро (как RDB)
  * Догоняет последние команды через AOF
* Лучший баланс для прод-систем

---

## Слайд 5. Конфигурация (пример)

```
--save 900 1
--save 300 10
--save 60 10000
--appendonly yes
--appendfsync everysec
--auto-aof-rewrite-percentage 100
--auto-aof-rewrite-min-size 64mb
--aof-use-rdb-preamble yes
```

---

## Слайд 6. Как работают правила save()?

Redis использует параметры формата:

```
save <seconds> <changes>
```

Условие срабатывания:

* прошло `seconds` секунд с **последнего успешного RDB**
* накопилось `changes` изменений (`dirty`)

**Оба условия должны быть выполнены.**

---

## Слайд 7. Важное: НЕТ отдельных таймеров!

Redis не заводит таймеры под каждое правило.

Он каждые ~100 мс выполняет цикл:

```
for rule in rules:
    if now - lastsave >= seconds AND dirty >= changes:
        bgsave()
        break
```

---

## Слайд 8. Пример: 10k изменений за минуту

Допустим:

* `lastsave = 00:00`
* За минуту (`00:00 → 00:01`) пришло 10k изменений

На одном из cron-тик‑ов Redis увидит:

* прошло ≥ 60 секунд
* dirty ≥ 10000
  → сработает правило `(60, 10000)`

---

## Слайд 9. Что происходит после bgsave?

После успешного RDB:

* `lastsave` обновляется на текущее время
* `dirty` сбрасывается в 0

**Все правила начинают отсчёт заново от нового `lastsave`.**

---

## Слайд 10. Почему порядок правил важен?

Правила проверяются сверху вниз:

1. `(900, 1)`
2. `(300, 10)`
3. `(60, 10000)`

Первое удовлетворившее — запускает RDB.

---

## Слайд 11. Как работает AOF?

* `appendonly yes` — включить лог
* `appendfsync everysec` — fsync раз в секунду
* `auto-aof-rewrite-*` — условия перепаковки AOF
* `aof-use-rdb-preamble yes` — гибридный формат

Процесс:

1. При записи → команда попадает в AOF
2. Раз в секунду → flush на диск
3. При росте файла → rewrite

---

## Слайд 12. Схема работы RDB + AOF

1. В фоне — периодические RDB согласно правилам
2. В реальном времени — логирование команд в AOF
3. При большой нагрузке — частые RDB
4. При старте Redis:

   * читается RDB-преамбула
   * затем проигрываются команды AOF

Результат: быстро и надёжно.

---

## Слайд 13. Почему этот подход выбирают в проде?

* Минимум потерь (AOF)
* Максимальная скорость восстановления (RDB)
* Чёткие predictable правила
* Низкая нагрузка на диск
* Возможность fine-tuning под свой трафик

---

## Слайд 14. Ключевой вывод

Redis проверяет правила **каждые 100мс**, а не по таймерам.

И запускает RDB только когда:

```
(now - lastsave >= seconds) && (dirty >= changes)
```

— и это делает гибридную политику предсказуемой и надёжной.

---

## Слайд 15. Вопросы?

Готов углубиться в dirty-флаги, fork-механику, AOF rewrite,
или моделирование нагрузки.

