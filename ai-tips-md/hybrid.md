Отлично — погружаемся в последовательность операций «под микроскопом». Я опишу пошагово, что происходит при **AOF rewrite с RDB-преамбулой** (то, что включается опцией `aof-use-rdb-preamble yes`). Буду разделять действия родителя (parent, основной процесс Redis) и дочернего процесса (child, который делает ре-райт). В конце — коротко про гарантийные случаи (что если упадём на разных шагах).

---

# Короткая идея в 1 строке

При rewrite создаётся **новый AOF-файл**, который начинается с **RDB-дампа** (быстро загружается при старте), затем в него добавляются команды, которые остаются после этого дампа — и в конце мы атомарно заменяем старый AOF на новый.

---

# Участники

* **Parent** — основной Redis-процесс, обслуживает клиентов, пишет в текущий (старый) AOF.
* **Child** — форкнутый процесс, который строит новый AOF (временный файл) в фоне.

---

# Предпосылки перед стартом rewrite

* У нас включён AOF (`appendonly yes`).
* `aof-use-rdb-preamble = yes`.
* Родитель в любой момент продолжает принимать команды, увеличивает `dirty` и дописывает в старый AOF (по политике `appendfsync`).
* Когда триггер на rewrite срабатывает — запускается `bgrewriteaof`.

---

# Пошаговая последовательность (временная линия)

### 1) Родитель форкает дочерний процесс

* Родитель вызывает `fork()`.
* Child получает снимок адресного пространства на момент fork (COW).

### 2) Child открывает *временный* файл new-aof (обычно `temp-rewriteaof.aof`)

* Child создаёт/открывает файл для записи нового AOF (обычно в том же каталоге).
* Если `aof-use-rdb-preamble = yes`, child сначала **записывает RDB-формат** в начало этого файла:

  * генерируется компактный бинарный дамп RDB (то же, что при rdbSave), записывается в начало temp-файла.
  * После записи RDB child может (и должен) **fsync** временный файл, чтобы на диске уже был корректный RDB-потомок (в целях устойчивости).

### 3) Child проходит по всей базе данных и генерирует «минимальный» набор команд

* После RDB-прембулы child просматривает ключи и для каждого ключа выписывает минимально-необходимую команду(ы) для восстановления состояния (например, `SET`/`EXPIRE`, `HMSET`/`HSET` и т.д.).
* Цель — компактный набор команд, который приведёт RDB-дамп к текущему моменту child-а.
* Child пишет эти команды ***в тот же temp-файл***, следом за RDB-прембулой. Иногда это называют «RDB + delta».

> Важно: child строит AOF **на основе снимка памяти на момент fork**. Он не видит последующие изменения, которые делает parent после fork.

### 4) Parent продолжает обслуживать клиентов и накапливает новые команды

* После fork родитель НЕ останавливается; он продолжает:

  * выполнять команды,
  * добавлять их в **старый AOF** (обычный путь),
  * и дополнительно — складывать их во внутренний буфер `aof_rewrite_buf` (или в структуру блоков буфера).
* Этот буфер нужен, чтобы не терять команды, которые пришли после fork, потому что child их не увидел.

### 5) Child завершает запись (fsync) и выходит

* Когда child закончил писать RDB + команды из снимка, он fsync'ит temp-файл и завершает работу, возвращая код успеха родителю (SIGCHLD).
* На этом этапе в файловой системе есть новый файл, начинающийся с корректного RDB и содержащий команды, соответствующие снимку child'а.

### 6) Parent получает сигнал завершения child и «доделывает» новый файл

* Parent читает буфер `aof_rewrite_buf` — все команды, которые пришли после fork.
* Parent **добавляет** этот буфер в конец нового temp-файла (то есть дописывает те команды, которых не было в снимке child'а) — тем самым новый файл становится полным и актуальным по состоянию на момент окончания rewrite (snapshot_time + buffered changes).
* Parent делает **fsync** нового файла (важно: сначала дочерний fsync, потом parent дописывает и fsync — порядок реализации может слегка отличаться, но цель одна: убедиться, что новый файл на диске цельный).

### 7) Атомарная замена старого AOF на новый

* После того как новый файл готов и зафсинчен, parent делает `rename(temp-rewriteaof.aof, appendonly.aof)` — атомальная операция в пределах файловой системы.
* В результате новый AOF заменяет старый. Старый файл безопасно удаляется ОС (или переименовывается/удаляется).
* Parent при необходимости обновляет внутренние счётчики/метаданные (например, положение для следующих rewrite).

---

# Что происходит при старте Redis (чтение гибридного файла)

* При старте если AOF в гибридном формате (с RDB-преамбулой) — Redis обнаружит RDB в начале файла:

  1. Сначала прочитает и загрузит RDB-дамп (быстро).
  2. Затем дочитает оставшуюся часть файла (AOF-команды) и **проиграет** их в порядке записи.
* Эффект: загрузка почти как при чистом RDB, но с дореплеем последних команд — быстро и точно.

---

# Короткая диаграмма (Parent / Child)

```
Time:      fork()  ---- child writes RDB+snapshot_commands ---- child fsync+exit
Parent:   | continues accepting writes -> writes old AOF -> buffers new commands |
After child exit: Parent appends buffered commands to new-file -> fsync -> rename -> done
```

---

# Гарантии и что важно знать (edge cases)

### A) Что если child упал/завершился с ошибкой?

* Ничего страшного: старый AOF остаётся нетронутым. Parent продолжает работать как прежде. Rewrite считается проваленным.

### B) Что если parent упал после fork, а child всё ещё жив?

* Child уже записал новый файл; но если parent упал до того, как он дописал буфер и сделал rename, при перезапуске Redis прочитает старый AOF (или, если rename успел — новый). Обычно код организован так, чтобы не потерять целостность: не делается замещающая операция, пока новый файл не готов.

### C) Какой риск потери команд?

* Если parent правильно дописал буфер и сделал fsync перед rename, риск минимален. Небезопасные ситуации — если ОС/диск упадёт между шагами без fsync. Redis старается fsync'ать на ключевых шагах (child fsync, parent fsync), но полная гарантия зависит от параметров `appendfsync` и поведения ОС.

### D) Что с производительностью во время rewrite?

* Fork создаёт COW нагрузку и может увеличить IO/память. Parent продолжает сервировать, но write amplification и диск-IO растут (child пишет temp-файл + parent пишет старый AOF + parent записывает буфер в конце). Нужно следить за нагрузкой.

---

# Дополнительные детали, которые часто интересуют инженеров

* **Буферизация parent'а:** родитель обычно использует структуру блоков (linked list of blocks) для буфера (`aof_rewrite_buf_blocks`), чтобы избежать постоянных аллокаций и для удобного дозаписывания в файл.
* **Fsnyc и ordering:** child обычно fsync'ит temp-файл; parent дописывает буфер и fsync'ит снова; важно, чтобы перед rename файл был на диске (или хотя бы в OS page cache, но для безопасного поведения — fsync).
* **Размеры и пороги:** rewrite инициируется по порогу роста (процент) и min size; эти пороги нужны, чтобы не запускать rewrite слишком часто при небольшом файле.
* **Atomic rename:** замена файла через rename — atomic в пределах одного mount point; это даёт гарантию «либо старый файл, либо новый».

---

# Итог (резюме шагов)

1. Parent вызывает `bgrewriteaof` → fork child.
2. Child создаёт temp-файл → записывает RDB-preamble (RDB дамп).
3. Child генерирует компактные команды по snapshot → записывает их далее в temp-файл → fsync → exit.
4. Parent в это время принимает команды и складывает их и в старый AOF, и в буфер `aof_rewrite_buf`.
5. После завершения child parent дозаписывает буфер в конец temp-файла → fsync.
6. Parent делает atomic `rename(temp, appendonly.aof)` — новый гибридный AOF готов.
7. При следующем старте Redis загрузит RDB из начала файла, затем проиграет хвост команд.

---

Если хочешь, могу:

* показать **псевдокод** для parent/child (чуть глубже, с проверками ошибок);
* смоделировать таймлайны с конкретными временными метками и последовательностью `fsync`/`rename`;
* добавить это в слайды и сделать диаграмму с буферами и точками fsync. Что предпочитаешь?
